import 'package:inilabs_assignment/features/home/domain/entities/repository_entity.dart';

class RepositoryModel extends RepositoryEntity {
  const RepositoryModel({
    required super.id,
    required super.nodeId,
    required super.name,
    required super.fullName,
    required super.private,
    required super.htmlUrl,
    super.description,
    required super.fork,
    required super.url,
    required super.createdAt,
    required super.updatedAt,
    required super.pushedAt,
    super.gitUrl,
    super.sshUrl,
    super.cloneUrl,
    super.svnUrl,
    super.homepage,
    required super.size,
    required super.stargazersCount,
    required super.watchersCount,
    super.language,
    required super.hasIssues,
    required super.hasProjects,
    required super.hasDownloads,
    required super.hasWiki,
    required super.hasPages,
    required super.hasDiscussions,
    required super.forksCount,
    super.mirrorUrl,
    required super.archived,
    required super.disabled,
    required super.openIssuesCount,
    super.license,
    required super.allowForking,
    required super.isTemplate,
    required super.topics,
    required super.visibility,
    required super.forks,
    required super.openIssues,
    required super.watchers,
    super.defaultBranch,
  });

  /// Create RepositoryModel from JSON
  factory RepositoryModel.fromJson(Map<String, dynamic> json) {
    return RepositoryModel(
      id: json['id'] as int,
      nodeId: json['node_id'] as String,
      name: json['name'] as String,
      fullName: json['full_name'] as String,
      private: json['private'] as bool,
      htmlUrl: json['html_url'] as String,
      description: json['description'] as String?,
      fork: json['fork'] as bool,
      url: json['url'] as String,
      createdAt: json['created_at'] as String,
      updatedAt: json['updated_at'] as String,
      pushedAt: json['pushed_at'] as String,
      gitUrl: json['git_url'] as String?,
      sshUrl: json['ssh_url'] as String?,
      cloneUrl: json['clone_url'] as String?,
      svnUrl: json['svn_url'] as String?,
      homepage: json['homepage'] as String?,
      size: json['size'] as int,
      stargazersCount: json['stargazers_count'] as int,
      watchersCount: json['watchers_count'] as int,
      language: json['language'] as String?,
      hasIssues: json['has_issues'] as bool,
      hasProjects: json['has_projects'] as bool,
      hasDownloads: json['has_downloads'] as bool,
      hasWiki: json['has_wiki'] as bool,
      hasPages: json['has_pages'] as bool,
      hasDiscussions: json['has_discussions'] as bool,
      forksCount: json['forks_count'] as int,
      mirrorUrl: json['mirror_url'] as String?,
      archived: json['archived'] as bool,
      disabled: json['disabled'] as bool,
      openIssuesCount: json['open_issues_count'] as int,
      license: json['license'] != null
          ? (json['license'] is Map
                ? (json['license'] as Map<String, dynamic>)['name'] as String?
                : json['license'] as String?)
          : null,
      allowForking: json['allow_forking'] as bool,
      isTemplate: json['is_template'] as bool,
      topics:
          (json['topics'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          [],
      visibility: json['visibility'] as String,
      forks: json['forks'] as int,
      openIssues: json['open_issues'] as int,
      watchers: json['watchers'] as int,
      defaultBranch: json['default_branch'] as String?,
    );
  }

  /// Convert RepositoryModel to JSON
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'node_id': nodeId,
      'name': name,
      'full_name': fullName,
      'private': private,
      'html_url': htmlUrl,
      'description': description,
      'fork': fork,
      'url': url,
      'created_at': createdAt,
      'updated_at': updatedAt,
      'pushed_at': pushedAt,
      'git_url': gitUrl,
      'ssh_url': sshUrl,
      'clone_url': cloneUrl,
      'svn_url': svnUrl,
      'homepage': homepage,
      'size': size,
      'stargazers_count': stargazersCount,
      'watchers_count': watchersCount,
      'language': language,
      'has_issues': hasIssues,
      'has_projects': hasProjects,
      'has_downloads': hasDownloads,
      'has_wiki': hasWiki,
      'has_pages': hasPages,
      'has_discussions': hasDiscussions,
      'forks_count': forksCount,
      'mirror_url': mirrorUrl,
      'archived': archived,
      'disabled': disabled,
      'open_issues_count': openIssuesCount,
      'license': license,
      'allow_forking': allowForking,
      'is_template': isTemplate,
      'topics': topics,
      'visibility': visibility,
      'forks': forks,
      'open_issues': openIssues,
      'watchers': watchers,
      'default_branch': defaultBranch,
    };
  }

  /// Convert RepositoryModel to RepositoryEntity
  RepositoryEntity toEntity() {
    return RepositoryEntity(
      id: id,
      nodeId: nodeId,
      name: name,
      fullName: fullName,
      private: private,
      htmlUrl: htmlUrl,
      description: description,
      fork: fork,
      url: url,
      createdAt: createdAt,
      updatedAt: updatedAt,
      pushedAt: pushedAt,
      gitUrl: gitUrl,
      sshUrl: sshUrl,
      cloneUrl: cloneUrl,
      svnUrl: svnUrl,
      homepage: homepage,
      size: size,
      stargazersCount: stargazersCount,
      watchersCount: watchersCount,
      language: language,
      hasIssues: hasIssues,
      hasProjects: hasProjects,
      hasDownloads: hasDownloads,
      hasWiki: hasWiki,
      hasPages: hasPages,
      hasDiscussions: hasDiscussions,
      forksCount: forksCount,
      mirrorUrl: mirrorUrl,
      archived: archived,
      disabled: disabled,
      openIssuesCount: openIssuesCount,
      license: license,
      allowForking: allowForking,
      isTemplate: isTemplate,
      topics: topics,
      visibility: visibility,
      forks: forks,
      openIssues: openIssues,
      watchers: watchers,
      defaultBranch: defaultBranch,
    );
  }
}
